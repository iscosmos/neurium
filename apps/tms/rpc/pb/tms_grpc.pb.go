// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: tms.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ProductCategory_CreateProductCategory_FullMethodName  = "/pb.ProductCategory/CreateProductCategory"
	ProductCategory_UpdateProductCategory_FullMethodName  = "/pb.ProductCategory/UpdateProductCategory"
	ProductCategory_DeleteProductCategory_FullMethodName  = "/pb.ProductCategory/DeleteProductCategory"
	ProductCategory_GetProductCategory_FullMethodName     = "/pb.ProductCategory/GetProductCategory"
	ProductCategory_GetProductCategoryTree_FullMethodName = "/pb.ProductCategory/GetProductCategoryTree"
)

// ProductCategoryClient is the client API for ProductCategory service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 产品分类
type ProductCategoryClient interface {
	// 创建产品分类
	CreateProductCategory(ctx context.Context, in *CreateProductCategoryReq, opts ...grpc.CallOption) (*CreateProductCategoryResp, error)
	// 更新产品分类
	UpdateProductCategory(ctx context.Context, in *UpdateProductCategoryReq, opts ...grpc.CallOption) (*UpdateProductCategoryResp, error)
	// 删除产品分类
	DeleteProductCategory(ctx context.Context, in *DeleteProductCategoryReq, opts ...grpc.CallOption) (*DeleteProductCategoryResp, error)
	// 查询产品分类
	GetProductCategory(ctx context.Context, in *GetProductCategoryReq, opts ...grpc.CallOption) (*GetProductCategoryResp, error)
	// 查询产品分类树
	GetProductCategoryTree(ctx context.Context, in *GetProductCategoryTreeReq, opts ...grpc.CallOption) (*GetProductCategoryTreeResp, error)
}

type productCategoryClient struct {
	cc grpc.ClientConnInterface
}

func NewProductCategoryClient(cc grpc.ClientConnInterface) ProductCategoryClient {
	return &productCategoryClient{cc}
}

func (c *productCategoryClient) CreateProductCategory(ctx context.Context, in *CreateProductCategoryReq, opts ...grpc.CallOption) (*CreateProductCategoryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProductCategoryResp)
	err := c.cc.Invoke(ctx, ProductCategory_CreateProductCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCategoryClient) UpdateProductCategory(ctx context.Context, in *UpdateProductCategoryReq, opts ...grpc.CallOption) (*UpdateProductCategoryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProductCategoryResp)
	err := c.cc.Invoke(ctx, ProductCategory_UpdateProductCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCategoryClient) DeleteProductCategory(ctx context.Context, in *DeleteProductCategoryReq, opts ...grpc.CallOption) (*DeleteProductCategoryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProductCategoryResp)
	err := c.cc.Invoke(ctx, ProductCategory_DeleteProductCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCategoryClient) GetProductCategory(ctx context.Context, in *GetProductCategoryReq, opts ...grpc.CallOption) (*GetProductCategoryResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProductCategoryResp)
	err := c.cc.Invoke(ctx, ProductCategory_GetProductCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productCategoryClient) GetProductCategoryTree(ctx context.Context, in *GetProductCategoryTreeReq, opts ...grpc.CallOption) (*GetProductCategoryTreeResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProductCategoryTreeResp)
	err := c.cc.Invoke(ctx, ProductCategory_GetProductCategoryTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductCategoryServer is the server API for ProductCategory service.
// All implementations must embed UnimplementedProductCategoryServer
// for forward compatibility.
//
// 产品分类
type ProductCategoryServer interface {
	// 创建产品分类
	CreateProductCategory(context.Context, *CreateProductCategoryReq) (*CreateProductCategoryResp, error)
	// 更新产品分类
	UpdateProductCategory(context.Context, *UpdateProductCategoryReq) (*UpdateProductCategoryResp, error)
	// 删除产品分类
	DeleteProductCategory(context.Context, *DeleteProductCategoryReq) (*DeleteProductCategoryResp, error)
	// 查询产品分类
	GetProductCategory(context.Context, *GetProductCategoryReq) (*GetProductCategoryResp, error)
	// 查询产品分类树
	GetProductCategoryTree(context.Context, *GetProductCategoryTreeReq) (*GetProductCategoryTreeResp, error)
	mustEmbedUnimplementedProductCategoryServer()
}

// UnimplementedProductCategoryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductCategoryServer struct{}

func (UnimplementedProductCategoryServer) CreateProductCategory(context.Context, *CreateProductCategoryReq) (*CreateProductCategoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductCategory not implemented")
}
func (UnimplementedProductCategoryServer) UpdateProductCategory(context.Context, *UpdateProductCategoryReq) (*UpdateProductCategoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProductCategory not implemented")
}
func (UnimplementedProductCategoryServer) DeleteProductCategory(context.Context, *DeleteProductCategoryReq) (*DeleteProductCategoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProductCategory not implemented")
}
func (UnimplementedProductCategoryServer) GetProductCategory(context.Context, *GetProductCategoryReq) (*GetProductCategoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductCategory not implemented")
}
func (UnimplementedProductCategoryServer) GetProductCategoryTree(context.Context, *GetProductCategoryTreeReq) (*GetProductCategoryTreeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductCategoryTree not implemented")
}
func (UnimplementedProductCategoryServer) mustEmbedUnimplementedProductCategoryServer() {}
func (UnimplementedProductCategoryServer) testEmbeddedByValue()                         {}

// UnsafeProductCategoryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductCategoryServer will
// result in compilation errors.
type UnsafeProductCategoryServer interface {
	mustEmbedUnimplementedProductCategoryServer()
}

func RegisterProductCategoryServer(s grpc.ServiceRegistrar, srv ProductCategoryServer) {
	// If the following call pancis, it indicates UnimplementedProductCategoryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProductCategory_ServiceDesc, srv)
}

func _ProductCategory_CreateProductCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductCategoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCategoryServer).CreateProductCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductCategory_CreateProductCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCategoryServer).CreateProductCategory(ctx, req.(*CreateProductCategoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCategory_UpdateProductCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductCategoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCategoryServer).UpdateProductCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductCategory_UpdateProductCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCategoryServer).UpdateProductCategory(ctx, req.(*UpdateProductCategoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCategory_DeleteProductCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProductCategoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCategoryServer).DeleteProductCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductCategory_DeleteProductCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCategoryServer).DeleteProductCategory(ctx, req.(*DeleteProductCategoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCategory_GetProductCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductCategoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCategoryServer).GetProductCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductCategory_GetProductCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCategoryServer).GetProductCategory(ctx, req.(*GetProductCategoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductCategory_GetProductCategoryTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductCategoryTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductCategoryServer).GetProductCategoryTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductCategory_GetProductCategoryTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductCategoryServer).GetProductCategoryTree(ctx, req.(*GetProductCategoryTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductCategory_ServiceDesc is the grpc.ServiceDesc for ProductCategory service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductCategory_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ProductCategory",
	HandlerType: (*ProductCategoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProductCategory",
			Handler:    _ProductCategory_CreateProductCategory_Handler,
		},
		{
			MethodName: "UpdateProductCategory",
			Handler:    _ProductCategory_UpdateProductCategory_Handler,
		},
		{
			MethodName: "DeleteProductCategory",
			Handler:    _ProductCategory_DeleteProductCategory_Handler,
		},
		{
			MethodName: "GetProductCategory",
			Handler:    _ProductCategory_GetProductCategory_Handler,
		},
		{
			MethodName: "GetProductCategoryTree",
			Handler:    _ProductCategory_GetProductCategoryTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tms.proto",
}

const (
	Product_CreateProduct_FullMethodName       = "/pb.Product/CreateProduct"
	Product_UpdateProduct_FullMethodName       = "/pb.Product/UpdateProduct"
	Product_DeleteProduct_FullMethodName       = "/pb.Product/DeleteProduct"
	Product_GetProduct_FullMethodName          = "/pb.Product/GetProduct"
	Product_ListProduct_FullMethodName         = "/pb.Product/ListProduct"
	Product_UpdateProductStatus_FullMethodName = "/pb.Product/UpdateProductStatus"
)

// ProductClient is the client API for Product service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductClient interface {
	// 创建产品
	CreateProduct(ctx context.Context, in *CreateProductReq, opts ...grpc.CallOption) (*CreateProductResp, error)
	// 更新产品
	UpdateProduct(ctx context.Context, in *UpdateProductReq, opts ...grpc.CallOption) (*UpdateProductResp, error)
	// 删除产品
	DeleteProduct(ctx context.Context, in *DeleteProductReq, opts ...grpc.CallOption) (*DeleteProductResp, error)
	// 产品详情
	GetProduct(ctx context.Context, in *GetProductReq, opts ...grpc.CallOption) (*GetProductResp, error)
	// 产品列表
	ListProduct(ctx context.Context, in *ListProductReq, opts ...grpc.CallOption) (*ListProductResp, error)
	// 修改发布状态
	UpdateProductStatus(ctx context.Context, in *UpdateProductStatusReq, opts ...grpc.CallOption) (*UpdateProductStatusResp, error)
}

type productClient struct {
	cc grpc.ClientConnInterface
}

func NewProductClient(cc grpc.ClientConnInterface) ProductClient {
	return &productClient{cc}
}

func (c *productClient) CreateProduct(ctx context.Context, in *CreateProductReq, opts ...grpc.CallOption) (*CreateProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProductResp)
	err := c.cc.Invoke(ctx, Product_CreateProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) UpdateProduct(ctx context.Context, in *UpdateProductReq, opts ...grpc.CallOption) (*UpdateProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProductResp)
	err := c.cc.Invoke(ctx, Product_UpdateProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) DeleteProduct(ctx context.Context, in *DeleteProductReq, opts ...grpc.CallOption) (*DeleteProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProductResp)
	err := c.cc.Invoke(ctx, Product_DeleteProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) GetProduct(ctx context.Context, in *GetProductReq, opts ...grpc.CallOption) (*GetProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProductResp)
	err := c.cc.Invoke(ctx, Product_GetProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) ListProduct(ctx context.Context, in *ListProductReq, opts ...grpc.CallOption) (*ListProductResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProductResp)
	err := c.cc.Invoke(ctx, Product_ListProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) UpdateProductStatus(ctx context.Context, in *UpdateProductStatusReq, opts ...grpc.CallOption) (*UpdateProductStatusResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProductStatusResp)
	err := c.cc.Invoke(ctx, Product_UpdateProductStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductServer is the server API for Product service.
// All implementations must embed UnimplementedProductServer
// for forward compatibility.
type ProductServer interface {
	// 创建产品
	CreateProduct(context.Context, *CreateProductReq) (*CreateProductResp, error)
	// 更新产品
	UpdateProduct(context.Context, *UpdateProductReq) (*UpdateProductResp, error)
	// 删除产品
	DeleteProduct(context.Context, *DeleteProductReq) (*DeleteProductResp, error)
	// 产品详情
	GetProduct(context.Context, *GetProductReq) (*GetProductResp, error)
	// 产品列表
	ListProduct(context.Context, *ListProductReq) (*ListProductResp, error)
	// 修改发布状态
	UpdateProductStatus(context.Context, *UpdateProductStatusReq) (*UpdateProductStatusResp, error)
	mustEmbedUnimplementedProductServer()
}

// UnimplementedProductServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductServer struct{}

func (UnimplementedProductServer) CreateProduct(context.Context, *CreateProductReq) (*CreateProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProduct not implemented")
}
func (UnimplementedProductServer) UpdateProduct(context.Context, *UpdateProductReq) (*UpdateProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProduct not implemented")
}
func (UnimplementedProductServer) DeleteProduct(context.Context, *DeleteProductReq) (*DeleteProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProduct not implemented")
}
func (UnimplementedProductServer) GetProduct(context.Context, *GetProductReq) (*GetProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProduct not implemented")
}
func (UnimplementedProductServer) ListProduct(context.Context, *ListProductReq) (*ListProductResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProduct not implemented")
}
func (UnimplementedProductServer) UpdateProductStatus(context.Context, *UpdateProductStatusReq) (*UpdateProductStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProductStatus not implemented")
}
func (UnimplementedProductServer) mustEmbedUnimplementedProductServer() {}
func (UnimplementedProductServer) testEmbeddedByValue()                 {}

// UnsafeProductServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductServer will
// result in compilation errors.
type UnsafeProductServer interface {
	mustEmbedUnimplementedProductServer()
}

func RegisterProductServer(s grpc.ServiceRegistrar, srv ProductServer) {
	// If the following call pancis, it indicates UnimplementedProductServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Product_ServiceDesc, srv)
}

func _Product_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_CreateProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).CreateProduct(ctx, req.(*CreateProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_UpdateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).UpdateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_UpdateProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).UpdateProduct(ctx, req.(*UpdateProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_DeleteProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).DeleteProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_DeleteProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).DeleteProduct(ctx, req.(*DeleteProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_GetProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).GetProduct(ctx, req.(*GetProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_ListProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).ListProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_ListProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).ListProduct(ctx, req.(*ListProductReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_UpdateProductStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).UpdateProductStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Product_UpdateProductStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).UpdateProductStatus(ctx, req.(*UpdateProductStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Product_ServiceDesc is the grpc.ServiceDesc for Product service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Product_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Product",
	HandlerType: (*ProductServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProduct",
			Handler:    _Product_CreateProduct_Handler,
		},
		{
			MethodName: "UpdateProduct",
			Handler:    _Product_UpdateProduct_Handler,
		},
		{
			MethodName: "DeleteProduct",
			Handler:    _Product_DeleteProduct_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _Product_GetProduct_Handler,
		},
		{
			MethodName: "ListProduct",
			Handler:    _Product_ListProduct_Handler,
		},
		{
			MethodName: "UpdateProductStatus",
			Handler:    _Product_UpdateProductStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tms.proto",
}

const (
	ProductEndpoint_CreateProductEndpoint_FullMethodName = "/pb.ProductEndpoint/CreateProductEndpoint"
	ProductEndpoint_UpdateProductEndpoint_FullMethodName = "/pb.ProductEndpoint/UpdateProductEndpoint"
	ProductEndpoint_DeleteProductEndpoint_FullMethodName = "/pb.ProductEndpoint/DeleteProductEndpoint"
	ProductEndpoint_GetProductEndpoint_FullMethodName    = "/pb.ProductEndpoint/GetProductEndpoint"
	ProductEndpoint_ListProductEndpoint_FullMethodName   = "/pb.ProductEndpoint/ListProductEndpoint"
)

// ProductEndpointClient is the client API for ProductEndpoint service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 产品通信地址
type ProductEndpointClient interface {
	// 创建产品通信地址
	CreateProductEndpoint(ctx context.Context, in *CreateProductEndpointReq, opts ...grpc.CallOption) (*CreateProductEndpointResp, error)
	// 更新产品通信地址
	UpdateProductEndpoint(ctx context.Context, in *UpdateProductEndpointReq, opts ...grpc.CallOption) (*UpdateProductEndpointResp, error)
	// 删除产品通信地址
	DeleteProductEndpoint(ctx context.Context, in *DeleteProductEndpointReq, opts ...grpc.CallOption) (*DeleteProductEndpointResp, error)
	// 查看产品通信地址
	GetProductEndpoint(ctx context.Context, in *GetProductEndpointReq, opts ...grpc.CallOption) (*GetProductEndpointResp, error)
	// 查看产品通信地址列表
	ListProductEndpoint(ctx context.Context, in *ListProductEndpointReq, opts ...grpc.CallOption) (*ListProductEndpointResp, error)
}

type productEndpointClient struct {
	cc grpc.ClientConnInterface
}

func NewProductEndpointClient(cc grpc.ClientConnInterface) ProductEndpointClient {
	return &productEndpointClient{cc}
}

func (c *productEndpointClient) CreateProductEndpoint(ctx context.Context, in *CreateProductEndpointReq, opts ...grpc.CallOption) (*CreateProductEndpointResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProductEndpointResp)
	err := c.cc.Invoke(ctx, ProductEndpoint_CreateProductEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productEndpointClient) UpdateProductEndpoint(ctx context.Context, in *UpdateProductEndpointReq, opts ...grpc.CallOption) (*UpdateProductEndpointResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProductEndpointResp)
	err := c.cc.Invoke(ctx, ProductEndpoint_UpdateProductEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productEndpointClient) DeleteProductEndpoint(ctx context.Context, in *DeleteProductEndpointReq, opts ...grpc.CallOption) (*DeleteProductEndpointResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProductEndpointResp)
	err := c.cc.Invoke(ctx, ProductEndpoint_DeleteProductEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productEndpointClient) GetProductEndpoint(ctx context.Context, in *GetProductEndpointReq, opts ...grpc.CallOption) (*GetProductEndpointResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProductEndpointResp)
	err := c.cc.Invoke(ctx, ProductEndpoint_GetProductEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productEndpointClient) ListProductEndpoint(ctx context.Context, in *ListProductEndpointReq, opts ...grpc.CallOption) (*ListProductEndpointResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProductEndpointResp)
	err := c.cc.Invoke(ctx, ProductEndpoint_ListProductEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductEndpointServer is the server API for ProductEndpoint service.
// All implementations must embed UnimplementedProductEndpointServer
// for forward compatibility.
//
// 产品通信地址
type ProductEndpointServer interface {
	// 创建产品通信地址
	CreateProductEndpoint(context.Context, *CreateProductEndpointReq) (*CreateProductEndpointResp, error)
	// 更新产品通信地址
	UpdateProductEndpoint(context.Context, *UpdateProductEndpointReq) (*UpdateProductEndpointResp, error)
	// 删除产品通信地址
	DeleteProductEndpoint(context.Context, *DeleteProductEndpointReq) (*DeleteProductEndpointResp, error)
	// 查看产品通信地址
	GetProductEndpoint(context.Context, *GetProductEndpointReq) (*GetProductEndpointResp, error)
	// 查看产品通信地址列表
	ListProductEndpoint(context.Context, *ListProductEndpointReq) (*ListProductEndpointResp, error)
	mustEmbedUnimplementedProductEndpointServer()
}

// UnimplementedProductEndpointServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductEndpointServer struct{}

func (UnimplementedProductEndpointServer) CreateProductEndpoint(context.Context, *CreateProductEndpointReq) (*CreateProductEndpointResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductEndpoint not implemented")
}
func (UnimplementedProductEndpointServer) UpdateProductEndpoint(context.Context, *UpdateProductEndpointReq) (*UpdateProductEndpointResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProductEndpoint not implemented")
}
func (UnimplementedProductEndpointServer) DeleteProductEndpoint(context.Context, *DeleteProductEndpointReq) (*DeleteProductEndpointResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProductEndpoint not implemented")
}
func (UnimplementedProductEndpointServer) GetProductEndpoint(context.Context, *GetProductEndpointReq) (*GetProductEndpointResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductEndpoint not implemented")
}
func (UnimplementedProductEndpointServer) ListProductEndpoint(context.Context, *ListProductEndpointReq) (*ListProductEndpointResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProductEndpoint not implemented")
}
func (UnimplementedProductEndpointServer) mustEmbedUnimplementedProductEndpointServer() {}
func (UnimplementedProductEndpointServer) testEmbeddedByValue()                         {}

// UnsafeProductEndpointServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductEndpointServer will
// result in compilation errors.
type UnsafeProductEndpointServer interface {
	mustEmbedUnimplementedProductEndpointServer()
}

func RegisterProductEndpointServer(s grpc.ServiceRegistrar, srv ProductEndpointServer) {
	// If the following call pancis, it indicates UnimplementedProductEndpointServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProductEndpoint_ServiceDesc, srv)
}

func _ProductEndpoint_CreateProductEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductEndpointReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductEndpointServer).CreateProductEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductEndpoint_CreateProductEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductEndpointServer).CreateProductEndpoint(ctx, req.(*CreateProductEndpointReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductEndpoint_UpdateProductEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductEndpointReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductEndpointServer).UpdateProductEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductEndpoint_UpdateProductEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductEndpointServer).UpdateProductEndpoint(ctx, req.(*UpdateProductEndpointReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductEndpoint_DeleteProductEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProductEndpointReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductEndpointServer).DeleteProductEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductEndpoint_DeleteProductEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductEndpointServer).DeleteProductEndpoint(ctx, req.(*DeleteProductEndpointReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductEndpoint_GetProductEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductEndpointReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductEndpointServer).GetProductEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductEndpoint_GetProductEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductEndpointServer).GetProductEndpoint(ctx, req.(*GetProductEndpointReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductEndpoint_ListProductEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductEndpointReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductEndpointServer).ListProductEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductEndpoint_ListProductEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductEndpointServer).ListProductEndpoint(ctx, req.(*ListProductEndpointReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductEndpoint_ServiceDesc is the grpc.ServiceDesc for ProductEndpoint service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductEndpoint_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ProductEndpoint",
	HandlerType: (*ProductEndpointServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProductEndpoint",
			Handler:    _ProductEndpoint_CreateProductEndpoint_Handler,
		},
		{
			MethodName: "UpdateProductEndpoint",
			Handler:    _ProductEndpoint_UpdateProductEndpoint_Handler,
		},
		{
			MethodName: "DeleteProductEndpoint",
			Handler:    _ProductEndpoint_DeleteProductEndpoint_Handler,
		},
		{
			MethodName: "GetProductEndpoint",
			Handler:    _ProductEndpoint_GetProductEndpoint_Handler,
		},
		{
			MethodName: "ListProductEndpoint",
			Handler:    _ProductEndpoint_ListProductEndpoint_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tms.proto",
}

const (
	ProductSchemaVersion_GetProductSchemaVersion_FullMethodName     = "/pb.ProductSchemaVersion/GetProductSchemaVersion"
	ProductSchemaVersion_GetProductSchemaVersionWith_FullMethodName = "/pb.ProductSchemaVersion/GetProductSchemaVersionWith"
)

// ProductSchemaVersionClient is the client API for ProductSchemaVersion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 产品物模型版本
type ProductSchemaVersionClient interface {
	// 查看物模型版本
	GetProductSchemaVersion(ctx context.Context, in *GetProductSchemaVersionReq, opts ...grpc.CallOption) (*GetProductSchemaVersionResp, error)
	// 根据产品和状态查询物模型版本
	GetProductSchemaVersionWith(ctx context.Context, in *GetProductSchemaVersionWithReq, opts ...grpc.CallOption) (*GetProductSchemaVersionWithResp, error)
}

type productSchemaVersionClient struct {
	cc grpc.ClientConnInterface
}

func NewProductSchemaVersionClient(cc grpc.ClientConnInterface) ProductSchemaVersionClient {
	return &productSchemaVersionClient{cc}
}

func (c *productSchemaVersionClient) GetProductSchemaVersion(ctx context.Context, in *GetProductSchemaVersionReq, opts ...grpc.CallOption) (*GetProductSchemaVersionResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProductSchemaVersionResp)
	err := c.cc.Invoke(ctx, ProductSchemaVersion_GetProductSchemaVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productSchemaVersionClient) GetProductSchemaVersionWith(ctx context.Context, in *GetProductSchemaVersionWithReq, opts ...grpc.CallOption) (*GetProductSchemaVersionWithResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProductSchemaVersionWithResp)
	err := c.cc.Invoke(ctx, ProductSchemaVersion_GetProductSchemaVersionWith_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductSchemaVersionServer is the server API for ProductSchemaVersion service.
// All implementations must embed UnimplementedProductSchemaVersionServer
// for forward compatibility.
//
// 产品物模型版本
type ProductSchemaVersionServer interface {
	// 查看物模型版本
	GetProductSchemaVersion(context.Context, *GetProductSchemaVersionReq) (*GetProductSchemaVersionResp, error)
	// 根据产品和状态查询物模型版本
	GetProductSchemaVersionWith(context.Context, *GetProductSchemaVersionWithReq) (*GetProductSchemaVersionWithResp, error)
	mustEmbedUnimplementedProductSchemaVersionServer()
}

// UnimplementedProductSchemaVersionServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductSchemaVersionServer struct{}

func (UnimplementedProductSchemaVersionServer) GetProductSchemaVersion(context.Context, *GetProductSchemaVersionReq) (*GetProductSchemaVersionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductSchemaVersion not implemented")
}
func (UnimplementedProductSchemaVersionServer) GetProductSchemaVersionWith(context.Context, *GetProductSchemaVersionWithReq) (*GetProductSchemaVersionWithResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductSchemaVersionWith not implemented")
}
func (UnimplementedProductSchemaVersionServer) mustEmbedUnimplementedProductSchemaVersionServer() {}
func (UnimplementedProductSchemaVersionServer) testEmbeddedByValue()                              {}

// UnsafeProductSchemaVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductSchemaVersionServer will
// result in compilation errors.
type UnsafeProductSchemaVersionServer interface {
	mustEmbedUnimplementedProductSchemaVersionServer()
}

func RegisterProductSchemaVersionServer(s grpc.ServiceRegistrar, srv ProductSchemaVersionServer) {
	// If the following call pancis, it indicates UnimplementedProductSchemaVersionServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProductSchemaVersion_ServiceDesc, srv)
}

func _ProductSchemaVersion_GetProductSchemaVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductSchemaVersionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaVersionServer).GetProductSchemaVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchemaVersion_GetProductSchemaVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaVersionServer).GetProductSchemaVersion(ctx, req.(*GetProductSchemaVersionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductSchemaVersion_GetProductSchemaVersionWith_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductSchemaVersionWithReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaVersionServer).GetProductSchemaVersionWith(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchemaVersion_GetProductSchemaVersionWith_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaVersionServer).GetProductSchemaVersionWith(ctx, req.(*GetProductSchemaVersionWithReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductSchemaVersion_ServiceDesc is the grpc.ServiceDesc for ProductSchemaVersion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductSchemaVersion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ProductSchemaVersion",
	HandlerType: (*ProductSchemaVersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProductSchemaVersion",
			Handler:    _ProductSchemaVersion_GetProductSchemaVersion_Handler,
		},
		{
			MethodName: "GetProductSchemaVersionWith",
			Handler:    _ProductSchemaVersion_GetProductSchemaVersionWith_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tms.proto",
}

const (
	ProductSchemaModule_CreateProductSchemaModule_FullMethodName = "/pb.ProductSchemaModule/CreateProductSchemaModule"
	ProductSchemaModule_UpdateProductSchemaModule_FullMethodName = "/pb.ProductSchemaModule/UpdateProductSchemaModule"
	ProductSchemaModule_DeleteProductSchemaModule_FullMethodName = "/pb.ProductSchemaModule/DeleteProductSchemaModule"
	ProductSchemaModule_GetProductSchemaModule_FullMethodName    = "/pb.ProductSchemaModule/GetProductSchemaModule"
	ProductSchemaModule_ListProductSchemaModule_FullMethodName   = "/pb.ProductSchemaModule/ListProductSchemaModule"
)

// ProductSchemaModuleClient is the client API for ProductSchemaModule service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 产品物模型模块
type ProductSchemaModuleClient interface {
	// 创建物模型模块
	CreateProductSchemaModule(ctx context.Context, in *CreateProductSchemaModuleReq, opts ...grpc.CallOption) (*CreateProductSchemaModuleResp, error)
	// 更新物模型模块
	UpdateProductSchemaModule(ctx context.Context, in *UpdateProductSchemaModuleReq, opts ...grpc.CallOption) (*UpdateProductSchemaModuleResp, error)
	// 删除物模型模块
	DeleteProductSchemaModule(ctx context.Context, in *DeleteProductSchemaModuleReq, opts ...grpc.CallOption) (*DeleteProductSchemaModuleResp, error)
	// 查看物模型模块
	GetProductSchemaModule(ctx context.Context, in *GetProductSchemaModuleReq, opts ...grpc.CallOption) (*GetProductSchemaModuleResp, error)
	// 物模型模块列表
	ListProductSchemaModule(ctx context.Context, in *ListProductSchemaModuleReq, opts ...grpc.CallOption) (*ListProductSchemaModuleResp, error)
}

type productSchemaModuleClient struct {
	cc grpc.ClientConnInterface
}

func NewProductSchemaModuleClient(cc grpc.ClientConnInterface) ProductSchemaModuleClient {
	return &productSchemaModuleClient{cc}
}

func (c *productSchemaModuleClient) CreateProductSchemaModule(ctx context.Context, in *CreateProductSchemaModuleReq, opts ...grpc.CallOption) (*CreateProductSchemaModuleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProductSchemaModuleResp)
	err := c.cc.Invoke(ctx, ProductSchemaModule_CreateProductSchemaModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productSchemaModuleClient) UpdateProductSchemaModule(ctx context.Context, in *UpdateProductSchemaModuleReq, opts ...grpc.CallOption) (*UpdateProductSchemaModuleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateProductSchemaModuleResp)
	err := c.cc.Invoke(ctx, ProductSchemaModule_UpdateProductSchemaModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productSchemaModuleClient) DeleteProductSchemaModule(ctx context.Context, in *DeleteProductSchemaModuleReq, opts ...grpc.CallOption) (*DeleteProductSchemaModuleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProductSchemaModuleResp)
	err := c.cc.Invoke(ctx, ProductSchemaModule_DeleteProductSchemaModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productSchemaModuleClient) GetProductSchemaModule(ctx context.Context, in *GetProductSchemaModuleReq, opts ...grpc.CallOption) (*GetProductSchemaModuleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProductSchemaModuleResp)
	err := c.cc.Invoke(ctx, ProductSchemaModule_GetProductSchemaModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productSchemaModuleClient) ListProductSchemaModule(ctx context.Context, in *ListProductSchemaModuleReq, opts ...grpc.CallOption) (*ListProductSchemaModuleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProductSchemaModuleResp)
	err := c.cc.Invoke(ctx, ProductSchemaModule_ListProductSchemaModule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductSchemaModuleServer is the server API for ProductSchemaModule service.
// All implementations must embed UnimplementedProductSchemaModuleServer
// for forward compatibility.
//
// 产品物模型模块
type ProductSchemaModuleServer interface {
	// 创建物模型模块
	CreateProductSchemaModule(context.Context, *CreateProductSchemaModuleReq) (*CreateProductSchemaModuleResp, error)
	// 更新物模型模块
	UpdateProductSchemaModule(context.Context, *UpdateProductSchemaModuleReq) (*UpdateProductSchemaModuleResp, error)
	// 删除物模型模块
	DeleteProductSchemaModule(context.Context, *DeleteProductSchemaModuleReq) (*DeleteProductSchemaModuleResp, error)
	// 查看物模型模块
	GetProductSchemaModule(context.Context, *GetProductSchemaModuleReq) (*GetProductSchemaModuleResp, error)
	// 物模型模块列表
	ListProductSchemaModule(context.Context, *ListProductSchemaModuleReq) (*ListProductSchemaModuleResp, error)
	mustEmbedUnimplementedProductSchemaModuleServer()
}

// UnimplementedProductSchemaModuleServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductSchemaModuleServer struct{}

func (UnimplementedProductSchemaModuleServer) CreateProductSchemaModule(context.Context, *CreateProductSchemaModuleReq) (*CreateProductSchemaModuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductSchemaModule not implemented")
}
func (UnimplementedProductSchemaModuleServer) UpdateProductSchemaModule(context.Context, *UpdateProductSchemaModuleReq) (*UpdateProductSchemaModuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProductSchemaModule not implemented")
}
func (UnimplementedProductSchemaModuleServer) DeleteProductSchemaModule(context.Context, *DeleteProductSchemaModuleReq) (*DeleteProductSchemaModuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProductSchemaModule not implemented")
}
func (UnimplementedProductSchemaModuleServer) GetProductSchemaModule(context.Context, *GetProductSchemaModuleReq) (*GetProductSchemaModuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductSchemaModule not implemented")
}
func (UnimplementedProductSchemaModuleServer) ListProductSchemaModule(context.Context, *ListProductSchemaModuleReq) (*ListProductSchemaModuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProductSchemaModule not implemented")
}
func (UnimplementedProductSchemaModuleServer) mustEmbedUnimplementedProductSchemaModuleServer() {}
func (UnimplementedProductSchemaModuleServer) testEmbeddedByValue()                             {}

// UnsafeProductSchemaModuleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductSchemaModuleServer will
// result in compilation errors.
type UnsafeProductSchemaModuleServer interface {
	mustEmbedUnimplementedProductSchemaModuleServer()
}

func RegisterProductSchemaModuleServer(s grpc.ServiceRegistrar, srv ProductSchemaModuleServer) {
	// If the following call pancis, it indicates UnimplementedProductSchemaModuleServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProductSchemaModule_ServiceDesc, srv)
}

func _ProductSchemaModule_CreateProductSchemaModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductSchemaModuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaModuleServer).CreateProductSchemaModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchemaModule_CreateProductSchemaModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaModuleServer).CreateProductSchemaModule(ctx, req.(*CreateProductSchemaModuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductSchemaModule_UpdateProductSchemaModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductSchemaModuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaModuleServer).UpdateProductSchemaModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchemaModule_UpdateProductSchemaModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaModuleServer).UpdateProductSchemaModule(ctx, req.(*UpdateProductSchemaModuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductSchemaModule_DeleteProductSchemaModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProductSchemaModuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaModuleServer).DeleteProductSchemaModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchemaModule_DeleteProductSchemaModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaModuleServer).DeleteProductSchemaModule(ctx, req.(*DeleteProductSchemaModuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductSchemaModule_GetProductSchemaModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductSchemaModuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaModuleServer).GetProductSchemaModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchemaModule_GetProductSchemaModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaModuleServer).GetProductSchemaModule(ctx, req.(*GetProductSchemaModuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductSchemaModule_ListProductSchemaModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductSchemaModuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaModuleServer).ListProductSchemaModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchemaModule_ListProductSchemaModule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaModuleServer).ListProductSchemaModule(ctx, req.(*ListProductSchemaModuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductSchemaModule_ServiceDesc is the grpc.ServiceDesc for ProductSchemaModule service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductSchemaModule_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ProductSchemaModule",
	HandlerType: (*ProductSchemaModuleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProductSchemaModule",
			Handler:    _ProductSchemaModule_CreateProductSchemaModule_Handler,
		},
		{
			MethodName: "UpdateProductSchemaModule",
			Handler:    _ProductSchemaModule_UpdateProductSchemaModule_Handler,
		},
		{
			MethodName: "DeleteProductSchemaModule",
			Handler:    _ProductSchemaModule_DeleteProductSchemaModule_Handler,
		},
		{
			MethodName: "GetProductSchemaModule",
			Handler:    _ProductSchemaModule_GetProductSchemaModule_Handler,
		},
		{
			MethodName: "ListProductSchemaModule",
			Handler:    _ProductSchemaModule_ListProductSchemaModule_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tms.proto",
}

const (
	ProductSchema_ListProductSchema_FullMethodName = "/pb.ProductSchema/ListProductSchema"
)

// ProductSchemaClient is the client API for ProductSchema service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 产品物模型
type ProductSchemaClient interface {
	// 产品物模型列表
	ListProductSchema(ctx context.Context, in *ListProductSchemaReq, opts ...grpc.CallOption) (*ListProductSchemaResp, error)
}

type productSchemaClient struct {
	cc grpc.ClientConnInterface
}

func NewProductSchemaClient(cc grpc.ClientConnInterface) ProductSchemaClient {
	return &productSchemaClient{cc}
}

func (c *productSchemaClient) ListProductSchema(ctx context.Context, in *ListProductSchemaReq, opts ...grpc.CallOption) (*ListProductSchemaResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProductSchemaResp)
	err := c.cc.Invoke(ctx, ProductSchema_ListProductSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductSchemaServer is the server API for ProductSchema service.
// All implementations must embed UnimplementedProductSchemaServer
// for forward compatibility.
//
// 产品物模型
type ProductSchemaServer interface {
	// 产品物模型列表
	ListProductSchema(context.Context, *ListProductSchemaReq) (*ListProductSchemaResp, error)
	mustEmbedUnimplementedProductSchemaServer()
}

// UnimplementedProductSchemaServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductSchemaServer struct{}

func (UnimplementedProductSchemaServer) ListProductSchema(context.Context, *ListProductSchemaReq) (*ListProductSchemaResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProductSchema not implemented")
}
func (UnimplementedProductSchemaServer) mustEmbedUnimplementedProductSchemaServer() {}
func (UnimplementedProductSchemaServer) testEmbeddedByValue()                       {}

// UnsafeProductSchemaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductSchemaServer will
// result in compilation errors.
type UnsafeProductSchemaServer interface {
	mustEmbedUnimplementedProductSchemaServer()
}

func RegisterProductSchemaServer(s grpc.ServiceRegistrar, srv ProductSchemaServer) {
	// If the following call pancis, it indicates UnimplementedProductSchemaServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProductSchema_ServiceDesc, srv)
}

func _ProductSchema_ListProductSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductSchemaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductSchemaServer).ListProductSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductSchema_ListProductSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductSchemaServer).ListProductSchema(ctx, req.(*ListProductSchemaReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductSchema_ServiceDesc is the grpc.ServiceDesc for ProductSchema service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductSchema_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.ProductSchema",
	HandlerType: (*ProductSchemaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProductSchema",
			Handler:    _ProductSchema_ListProductSchema_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tms.proto",
}
